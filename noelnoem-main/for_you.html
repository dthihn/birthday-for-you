<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Birthday Giang üéÇ | M√≥n qu√† nh·ªè</title>
    <link rel="icon" href="https://img.icons8.com/color/48/heart-with-arrow--v1.png" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            overflow-x: hidden;
            background: linear-gradient(to bottom, #190021 0%, #060013 52%, #000010 100%);
            font-family: 'Nunito', sans-serif;
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 40px 0 20px 0;
            box-sizing: border-box;
            transition: opacity 0.5s ease;
        }

        .ui-hidden { opacity: 0 !important; pointer-events: none !important; }

        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, rgba(32, 3, 48, 0.7), #000);
            z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-out;
        }
        .loader-text {
            color: #ffd8a0; font-size: 14px; letter-spacing: 3px; margin-top: 20px;
            text-transform: uppercase; font-weight: 300;
        }
        .spinner {
            width: 40px; height: 40px; border: 1px solid rgba(255, 216, 160, 0.2);
            border-top: 1px solid #ffd8a0; border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        #start-btn {
            display: none;
            margin-top: 20px;
            background: transparent;
            color: #ffd8a0;
            border: 1px solid #ffd8a0;
            padding: 15px 40px;
            font-size: 16px;
            letter-spacing: 2px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Nunito', sans-serif;
            font-weight: 700;
        }
        #start-btn:hover {
            background: #ffd8a0; color: #2b0326;
            box-shadow: 0 0 30px rgba(255, 216, 160, 0.6);
        }
        .gift-icon {
            display: inline-block;
            margin-left: 8px;
            animation: giftBounce 1.5s ease-in-out infinite;
            transform-origin: center;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes giftBounce {
            0%,100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-3px) scale(1.13); }
        }

        h1 {
            color: #fceea7; font-size: 56px; margin: 0; font-weight: 400;
            letter-spacing: 6px;
            text-shadow: 0 0 50px rgba(252, 238, 167, 0.6);
            background: linear-gradient(to bottom, #fff, #ffd39d);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-family: 'Dancing Script', cursive;
            opacity: 0.95;
        }

        .name-badge {
            margin-bottom: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(212, 175, 55, 0.4);
            color: #d4af37;
            padding: 10px 30px;
            border-radius: 50px;
            font-family: 'Cinzel', serif;
            font-size: 20px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.3);
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.8);
            backdrop-filter: blur(5px);
            animation: glow 3s infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 20px rgba(212, 175, 55, 0.2); border-color: rgba(212, 175, 55, 0.3); }
            to { box-shadow: 0 0 40px rgba(212, 175, 55, 0.6); border-color: rgba(212, 175, 55, 0.8); }
        }

        .hint-text {
            position: absolute; bottom: 5px; right: 10px;
            color: rgba(255, 195, 140, 0.35); font-size: 10px;
            letter-spacing: 1px; text-transform: uppercase; pointer-events: none;
        }

        @media screen and (max-width: 768px) {
            h1 {
                font-size: 28px !important;
                line-height: 1.2;
            }
            .btn-open, .btn-click {
                transform: scale(0.8);
            }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">ƒêang chu·∫©n b·ªã ƒëi·ªÅu b·∫•t ng·ªù...</div>
        <button id="start-btn">Kh√°m ph√° m√≥n qu√† nh·ªè ‚ù§Ô∏è <span class="gift-icon">üéÅ</span></button>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1>Happy Birthday</h1>
        <div class="name-badge">üéÇ NG√î THANH GIANG üéÇ</div>
        <div class="hint-text">Move mouse / touch screen to scatter & reform</div>
    </div>

    <audio id="bg-audio" src="./audio.mp3" loop></audio>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            colors: {
                cream: 0xFFFDD0,
                pink: 0xFFD1DC,
                ruby: 0xE32636,
                gold: 0xFFD700,
                candleOrange: 0xFF9A00,
                candleYellow: 0xFFE066,
                bokehPink: 0xFFC1D6,
                bokehGold: 0xFFE39A
            },
            camera: { z: 58 },
            tiers: [
                { radius: 12, height: 5.2, yCenter: -6.2, count: 3000 },
                { radius: 8.5, height: 4.6, yCenter: -1.0, count: 2300 },
                { radius: 5.6, height: 3.9, yCenter: 3.0, count: 1700 }
            ],
            decorations: { sphereCount: 620 },
            candleCount: 5,
            interaction: { radius: 8.8, force: 17.5, damping: 0.86, returnStrength: 0.08 }
        };

        let scene, camera, renderer, composer, cakeGroup, clock;
        const particles = [];
        let flameSystem, bokehSystem;
        const mouse = new THREE.Vector2(999, 999);
        const pointer3D = new THREE.Vector3(999, 999, 0);
        const raycaster = new THREE.Raycaster();
        const interactionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        let started = false;

        const bgAudio = document.getElementById('bg-audio');

        class CakeVoxel {
            constructor(mesh, homePos, isDecoration = false) {
                this.mesh = mesh;
                this.home = homePos.clone();
                this.velocity = new THREE.Vector3();
                this.isDecoration = isDecoration;
                this.spin = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2);
            }

            update(dt, pointer, hasInteraction) {
                const pos = this.mesh.position;
                const toHome = this.home.clone().sub(pos).multiplyScalar(CONFIG.interaction.returnStrength);
                this.velocity.add(toHome);

                if (hasInteraction) {
                    const dir = pos.clone().sub(pointer);
                    const dist = dir.length();
                    if (dist < CONFIG.interaction.radius) {
                        const power = (1 - dist / CONFIG.interaction.radius) * CONFIG.interaction.force;
                        dir.normalize().multiplyScalar(power * dt * (this.isDecoration ? 1.4 : 1.0));
                        this.velocity.add(dir);
                        if (!started) triggerAudio();
                    }
                }

                this.velocity.multiplyScalar(CONFIG.interaction.damping);
                pos.addScaledVector(this.velocity, dt * 8.4);

                if (this.isDecoration) {
                    this.mesh.rotation.x += this.spin.x * dt * 0.6;
                    this.mesh.rotation.y += this.spin.y * dt * 0.6;
                    this.mesh.rotation.z += this.spin.z * dt * 0.6;
                }
            }
        }

        function init() {
            clock = new THREE.Clock();
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x120019, 0.012);

            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1200);
            camera.position.set(0, 2, CONFIG.camera.z);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.08;
            container.appendChild(renderer.domElement);

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.3, 0.9, 0.2);
            bloomPass.threshold = 0.06;
            bloomPass.radius = 0.85;
            composer.addPass(bloomPass);

            setupLights();
            createCake();
            createCandlesAndFlames();
            createBokeh();
            setupEvents();
            finishLoading();
            animate();
        }

        function setupLights() {
            scene.add(new THREE.AmbientLight(0xffecde, 0.5));

            const key = new THREE.PointLight(0xffd7aa, 2.1, 120);
            key.position.set(0, 14, 18);
            scene.add(key);

            const rim = new THREE.PointLight(0xff9fbe, 1.0, 100);
            rim.position.set(-18, 7, -24);
            scene.add(rim);

            const fill = new THREE.DirectionalLight(0xfff1d6, 0.7);
            fill.position.set(8, 12, 30);
            scene.add(fill);
        }

        function randomInCylinder(radius, height, yCenter) {
            const a = Math.random() * Math.PI * 2;
            const r = Math.sqrt(Math.random()) * radius;
            const x = Math.cos(a) * r;
            const z = Math.sin(a) * r;
            const y = yCenter + (Math.random() - 0.5) * height;
            return new THREE.Vector3(x, y, z);
        }

        function createCake() {
            cakeGroup = new THREE.Group();
            scene.add(cakeGroup);

            const creamMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.cream, roughness: 0.55, metalness: 0.08 });
            const pinkMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.pink, roughness: 0.52, metalness: 0.06 });
            const rubyMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.ruby, roughness: 0.25, metalness: 0.35 });
            const goldMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.2, metalness: 0.62, emissive: 0x5a3c00, emissiveIntensity: 0.1 });

            const boxGeo = new THREE.BoxGeometry(0.48, 0.48, 0.48);
            const sphereGeo = new THREE.SphereGeometry(0.26, 8, 8);

            CONFIG.tiers.forEach((tier, tierIndex) => {
                for (let i = 0; i < tier.count; i++) {
                    const home = randomInCylinder(tier.radius, tier.height, tier.yCenter);
                    const mat = (tierIndex + i) % 4 === 0 ? pinkMat : creamMat;
                    const voxel = new THREE.Mesh(boxGeo, mat);
                    voxel.position.copy(home);
                    voxel.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    cakeGroup.add(voxel);
                    particles.push(new CakeVoxel(voxel, home, false));
                }
            });

            for (let i = 0; i < CONFIG.decorations.sphereCount; i++) {
                const tier = CONFIG.tiers[Math.floor(Math.random() * CONFIG.tiers.length)];
                const angle = Math.random() * Math.PI * 2;
                const radial = tier.radius + 0.3 + Math.random() * 0.5;
                const y = tier.yCenter + (Math.random() - 0.5) * tier.height;
                const home = new THREE.Vector3(Math.cos(angle) * radial, y, Math.sin(angle) * radial);

                const sphere = new THREE.Mesh(sphereGeo, i % 2 ? rubyMat : goldMat);
                sphere.position.copy(home);
                cakeGroup.add(sphere);
                particles.push(new CakeVoxel(sphere, home, true));
            }
        }

        function createFlameTexture() {
            const c = document.createElement('canvas');
            c.width = 128; c.height = 128;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(64, 64, 4, 64, 64, 60);
            g.addColorStop(0, 'rgba(255,255,220,1)');
            g.addColorStop(0.35, 'rgba(255,212,102,0.95)');
            g.addColorStop(0.7, 'rgba(255,144,0,0.6)');
            g.addColorStop(1, 'rgba(255,120,0,0)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(64, 64, 60, 0, Math.PI * 2);
            ctx.fill();
            return new THREE.CanvasTexture(c);
        }

        function createCandlesAndFlames() {
            const candlePositions = [[0, 5.8, 0], [2.4, 5.8, 1.4], [-2.4, 5.8, 1.3], [2.2, 5.8, -1.5], [-2.2, 5.8, -1.4]];
            const candleMat = new THREE.MeshStandardMaterial({ color: 0xfff0d9, roughness: 0.45, metalness: 0.05 });
            const candleGeo = new THREE.CylinderGeometry(0.18, 0.2, 2.1, 10);

            const flamePositions = [];
            candlePositions.slice(0, CONFIG.candleCount).forEach(([x, y, z]) => {
                const candle = new THREE.Mesh(candleGeo, candleMat);
                candle.position.set(x, y + 1.1, z);
                cakeGroup.add(candle);
                for (let i = 0; i < 65; i++) {
                    flamePositions.push(x + (Math.random()-0.5)*0.22, y + 2.25 + (Math.random()-0.35)*0.75, z + (Math.random()-0.5)*0.22);
                }
            });

            const flameGeo = new THREE.BufferGeometry();
            flameGeo.setAttribute('position', new THREE.Float32BufferAttribute(flamePositions, 3));
            const flameMat = new THREE.PointsMaterial({
                color: CONFIG.colors.candleYellow,
                size: 0.64,
                map: createFlameTexture(),
                transparent: true,
                opacity: 0.98,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            flameSystem = new THREE.Points(flameGeo, flameMat);
            cakeGroup.add(flameSystem);
        }

        function createBokehTexture() {
            const c = document.createElement('canvas');
            c.width = 128; c.height = 128;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.5, 'rgba(255,235,210,0.8)');
            g.addColorStop(1, 'rgba(255,235,210,0)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(64, 64, 62, 0, Math.PI * 2);
            ctx.fill();
            return new THREE.CanvasTexture(c);
        }

        function createBokeh() {
            const count = 1200;
            const positions = [];
            const colors = [];
            const colorA = new THREE.Color(CONFIG.colors.bokehPink);
            const colorB = new THREE.Color(CONFIG.colors.bokehGold);

            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 30 + Math.random() * 85;
                const y = -25 + Math.random() * 70;
                positions.push(Math.cos(angle) * radius, y, Math.sin(angle) * radius - 70);

                const blend = Math.random();
                const c = colorA.clone().lerp(colorB, blend).multiplyScalar(0.65 + Math.random() * 0.35);
                colors.push(c.r, c.g, c.b);
            }

            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            g.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const m = new THREE.PointsMaterial({
                size: 1.25,
                map: createBokehTexture(),
                transparent: true,
                opacity: 0.32,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            bokehSystem = new THREE.Points(g, m);
            scene.add(bokehSystem);
        }

        function updatePointerFromScreen(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(interactionPlane, pointer3D);
        }

        function triggerAudio() {
            if (started) return;
            started = true;
            bgAudio.play().catch(() => {});
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            window.addEventListener('mousemove', (e) => {
                updatePointerFromScreen(e.clientX, e.clientY);
                triggerAudio();
            }, { passive: true });

            window.addEventListener('touchstart', (e) => {
                if (e.touches[0]) {
                    updatePointerFromScreen(e.touches[0].clientX, e.touches[0].clientY);
                    triggerAudio();
                }
            }, { passive: true });

            window.addEventListener('touchmove', (e) => {
                if (e.touches[0]) updatePointerFromScreen(e.touches[0].clientX, e.touches[0].clientY);
            }, { passive: true });

            window.addEventListener('mouseleave', () => {
                mouse.set(999, 999);
                pointer3D.set(999, 999, 0);
            });
        }

        function finishLoading() {
            const loader = document.getElementById('loader');
            const spinner = document.querySelector('.spinner');
            const loaderText = document.querySelector('.loader-text');
            const startBtn = document.getElementById('start-btn');

            spinner.style.display = 'none';
            loaderText.style.display = 'none';
            startBtn.style.display = 'block';

            startBtn.addEventListener('click', () => {
                const elem = document.documentElement;
                if (elem.requestFullscreen) elem.requestFullscreen().catch(() => {});
                triggerAudio();
                loader.style.opacity = 0;
                setTimeout(() => loader.remove(), 800);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.033);
            const t = clock.elapsedTime;

            const hasInteraction = Number.isFinite(pointer3D.x) && Math.abs(pointer3D.x) < 300;
            particles.forEach(p => p.update(dt, pointer3D, hasInteraction));

            cakeGroup.rotation.y += 0.16 * dt;
            cakeGroup.rotation.x = Math.sin(t * 0.4) * 0.04;

            if (flameSystem) {
                const arr = flameSystem.geometry.attributes.position.array;
                for (let i = 1; i < arr.length; i += 3) {
                    arr[i] += Math.sin(t * 9 + i) * 0.004;
                }
                flameSystem.geometry.attributes.position.needsUpdate = true;
            }

            if (bokehSystem) {
                bokehSystem.rotation.y += 0.004 * dt;
                bokehSystem.position.y = Math.sin(t * 0.2) * 1.5;
            }

            composer.render();
        }

        init();
    </script>
</body>
</html>
