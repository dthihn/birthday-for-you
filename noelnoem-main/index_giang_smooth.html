<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Birthday Giang üéÇ | M√≥n qu√† nh·ªè</title>
    <link rel="icon" href="https://img.icons8.com/color/48/heart-with-arrow--v1.png" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Nunito', sans-serif;
            background: radial-gradient(circle at 25% 15%, #2a396b 0%, #111831 38%, #060915 70%, #020207 100%);
        }

        #canvas-container { position: absolute; inset: 0; z-index: 1; }

        #ui-layer {
            position: absolute;
            inset: 0;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 40px 0 20px;
            box-sizing: border-box;
        }

        h1 {
            color: #fceea7;
            font-size: 56px;
            margin: 0;
            font-weight: 400;
            letter-spacing: 6px;
            text-shadow: 0 0 50px rgba(252, 238, 167, 0.6);
            background: linear-gradient(to bottom, #fff, #eebb66);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-family: 'Dancing Script', cursive;
            opacity: 0.95;
        }

        .name-badge {
            margin-bottom: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(212, 175, 55, 0.4);
            color: #d4af37;
            padding: 10px 30px;
            border-radius: 50px;
            font-size: 20px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.3);
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.8);
            backdrop-filter: blur(5px);
            animation: glow 3s infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 20px rgba(212, 175, 55, 0.2); border-color: rgba(212, 175, 55, 0.3); }
            to { box-shadow: 0 0 40px rgba(212, 175, 55, 0.6); border-color: rgba(212, 175, 55, 0.8); }
        }

        .hint-text {
            position: absolute;
            right: 10px;
            bottom: 5px;
            color: rgba(212, 175, 55, 0.38);
            font-size: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        @media screen and (max-width: 768px) {
            h1 { font-size: 32px; line-height: 1.2; }
            .name-badge { font-size: 16px; padding: 10px 22px; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
<div id="canvas-container"></div>
<div id="ui-layer">
    <h1>Happy Birthday</h1>
    <div class="name-badge">üéÇ Ng√¥ Thanh Giang üéÇ</div>
    <div class="hint-text">Move mouse / touch to scatter & reform the cake</div>
</div>

<script type="module">
    import * as THREE from 'three';

    const COLORS = {
        vanilla: 0xFFFDD0,
        pink: 0xFFD1DC,
        ruby: 0xE32636,
        gold: 0xFFD700,
        roseGold: 0xE6BEAE,
        lightBlue: 0x9ED5FF,
        white: 0xFFFFFF,
        candleRed: 0xFF3B3B,
        flameOrange: 0xFFA500,
        flameYellow: 0xFFFF00
    };

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(46, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 46);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const key = new THREE.DirectionalLight(0xfff0da, 1.25);
    key.position.set(14, 22, 20);
    scene.add(key);
    const rim = new THREE.DirectionalLight(0x88aaff, 0.5);
    rim.position.set(-20, 8, -18);
    scene.add(rim);

    const cakeGroup = new THREE.Group();
    scene.add(cakeGroup);

    const particles = [];
    const flames = [];

    class CakeParticle {
        constructor(mesh, origin, weight = 1) {
            this.mesh = mesh;
            this.origin = origin.clone();
            this.velocity = new THREE.Vector3();
            this.weight = weight;
            this.seed = Math.random() * Math.PI * 2;
        }

        update(dt, pointer, time) {
            const toOrigin = this.origin.clone().sub(this.mesh.position).multiplyScalar(7.5 * dt);
            this.velocity.add(toOrigin);

            const dx = this.mesh.position.x - pointer.world.x;
            const dz = this.mesh.position.z - pointer.world.z;
            const dy = this.mesh.position.y - pointer.world.y;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            if (pointer.active && distance < pointer.radius) {
                const f = (1 - distance / pointer.radius) * pointer.strength * dt * this.weight;
                this.velocity.x += (dx / (distance + 0.001)) * f;
                this.velocity.y += (dy / (distance + 0.001)) * f * 0.35;
                this.velocity.z += (dz / (distance + 0.001)) * f;
            }

            this.velocity.x += Math.sin(time * 1.4 + this.seed) * 0.0012;
            this.velocity.z += Math.cos(time * 1.2 + this.seed) * 0.0012;
            this.velocity.multiplyScalar(0.92);
            this.mesh.position.addScaledVector(this.velocity, dt * 60);

            this.mesh.rotation.x += this.velocity.z * 0.02;
            this.mesh.rotation.y += this.velocity.x * 0.02;
        }
    }

    const materials = {
        vanilla: new THREE.MeshStandardMaterial({ color: COLORS.vanilla, roughness: 0.5, metalness: 0.08 }),
        pink: new THREE.MeshStandardMaterial({ color: COLORS.pink, roughness: 0.55, metalness: 0.06 }),
        ruby: new THREE.MeshStandardMaterial({ color: COLORS.ruby, roughness: 0.38, metalness: 0.2 }),
        gold: new THREE.MeshStandardMaterial({ color: COLORS.gold, roughness: 0.2, metalness: 0.88 }),
        roseGold: new THREE.MeshStandardMaterial({ color: COLORS.roseGold, roughness: 0.3, metalness: 0.72 }),
        lightBlue: new THREE.MeshStandardMaterial({ color: COLORS.lightBlue, roughness: 0.25, metalness: 0.4 }),
        white: new THREE.MeshStandardMaterial({ color: COLORS.white, roughness: 0.25, metalness: 0.22 }),
        candleWhite: new THREE.MeshStandardMaterial({ color: COLORS.white, roughness: 0.4, metalness: 0.1 }),
        candleRed: new THREE.MeshStandardMaterial({ color: COLORS.candleRed, roughness: 0.35, metalness: 0.25 }),
        flameOrange: new THREE.MeshStandardMaterial({ color: COLORS.flameOrange, emissive: COLORS.flameOrange, emissiveIntensity: 2.8 }),
        flameYellow: new THREE.MeshStandardMaterial({ color: COLORS.flameYellow, emissive: COLORS.flameYellow, emissiveIntensity: 3.2 })
    };

    const geometries = {
        cakeCube: new THREE.BoxGeometry(0.62, 0.62, 0.62),
        borderSphere: new THREE.SphereGeometry(0.34, 12, 12),
        pipingSphere: new THREE.SphereGeometry(0.2, 10, 10),
        sprinkleCube: new THREE.BoxGeometry(0.14, 0.14, 0.14),
        candleBit: new THREE.CylinderGeometry(0.12, 0.12, 0.34, 10),
        flameDot: new THREE.SphereGeometry(0.11, 10, 10)
    };

    function addParticle(mesh, x, y, z, w = 1) {
        mesh.position.set(x, y, z);
        cakeGroup.add(mesh);
        particles.push(new CakeParticle(mesh, mesh.position, w));
    }

    function buildTier({ radius, height, centerY, mat }) {
        const step = 0.66;
        const half = height / 2;

        for (let y = centerY - half; y <= centerY + half; y += step) {
            for (let x = -radius; x <= radius; x += step) {
                for (let z = -radius; z <= radius; z += step) {
                    const radial = Math.sqrt(x * x + z * z);
                    if (radial <= radius - 0.05) {
                        const cube = new THREE.Mesh(geometries.cakeCube, mat);
                        addParticle(cube, x, y, z);
                    }
                }
            }
        }

        const bottomY = centerY - half - 0.24;
        const topY = centerY + half + 0.08;
        const rubyCount = Math.max(26, Math.floor(radius * 16));
        const goldCount = Math.max(34, Math.floor(radius * 22));

        for (let i = 0; i < rubyCount; i++) {
            const a = (i / rubyCount) * Math.PI * 2;
            const rr = radius + 0.12;
            const s = new THREE.Mesh(geometries.borderSphere, materials.ruby);
            addParticle(s, Math.cos(a) * rr, bottomY, Math.sin(a) * rr, 1.15);
        }

        for (let i = 0; i < goldCount; i++) {
            const a = (i / goldCount) * Math.PI * 2;
            const rr = radius + 0.02;
            const s = new THREE.Mesh(geometries.pipingSphere, materials.gold);
            addParticle(s, Math.cos(a) * rr, topY, Math.sin(a) * rr, 1.05);
        }

        const sprinkleCount = Math.floor(radius * 40);
        const sprinkleMats = [materials.roseGold, materials.lightBlue, materials.white];
        for (let i = 0; i < sprinkleCount; i++) {
            const a = Math.random() * Math.PI * 2;
            const rr = Math.random() * (radius - 0.8);
            const sY = centerY + (Math.random() - 0.5) * (height * 0.85);
            const sprinkle = new THREE.Mesh(geometries.sprinkleCube, sprinkleMats[i % sprinkleMats.length]);
            sprinkle.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
            addParticle(sprinkle, Math.cos(a) * rr, sY, Math.sin(a) * rr, 0.9);
        }
    }

    function buildCandle(basePos) {
        const segments = 8;
        for (let i = 0; i < segments; i++) {
            const mat = i % 2 === 0 ? materials.candleWhite : materials.candleRed;
            const bit = new THREE.Mesh(geometries.candleBit, mat);
            addParticle(bit, basePos.x, basePos.y + i * 0.35, basePos.z, 1.25);
        }

        const flameCenter = new THREE.Vector3(basePos.x, basePos.y + segments * 0.35 + 0.22, basePos.z);
        const flameGroup = [];
        for (let i = 0; i < 20; i++) {
            const mat = i % 2 === 0 ? materials.flameOrange : materials.flameYellow;
            const dot = new THREE.Mesh(geometries.flameDot, mat);
            const r = 0.22 * Math.pow(Math.random(), 0.65);
            const a = Math.random() * Math.PI * 2;
            const y = (Math.random() - 0.5) * 0.28;
            addParticle(dot, flameCenter.x + Math.cos(a) * r, flameCenter.y + y, flameCenter.z + Math.sin(a) * r, 1.45);
            flameGroup.push(dot);
        }

        const glow = new THREE.PointLight(0xffb347, 1.5, 10, 2);
        glow.position.copy(flameCenter);
        scene.add(glow);
        flames.push({ meshes: flameGroup, light: glow, center: flameCenter, seed: Math.random() * 6.28 });
    }

    function buildCake() {
        const H = 4.6;
        const R = 10;

        const tiers = [
            { radius: R, height: H, centerY: -8, mat: materials.vanilla },
            { radius: 0.75 * R, height: H, centerY: -3.2, mat: materials.pink },
            { radius: 0.45 * R, height: 0.8 * H, centerY: 1.4, mat: materials.vanilla }
        ];

        tiers.forEach(buildTier);

        const candleCount = 5;
        const candleRadius = 2.1;
        const topY = 3.15;
        for (let i = 0; i < candleCount; i++) {
            const a = (i / candleCount) * Math.PI * 2;
            buildCandle(new THREE.Vector3(Math.cos(a) * candleRadius, topY, Math.sin(a) * candleRadius));
        }
    }

    buildCake();

    const pointer = {
        active: false,
        x: 0,
        y: 0,
        world: new THREE.Vector3(999, 999, 999),
        radius: 8.8,
        strength: 26
    };

    const raycaster = new THREE.Raycaster();
    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    const target = new THREE.Vector3();

    function updatePointer(clientX, clientY, active = true) {
        pointer.x = (clientX / innerWidth) * 2 - 1;
        pointer.y = -(clientY / innerHeight) * 2 + 1;
        pointer.active = active;
        raycaster.setFromCamera({ x: pointer.x, y: pointer.y }, camera);
        raycaster.ray.intersectPlane(plane, target);
        pointer.world.copy(target);
    }

    addEventListener('mousemove', (e) => updatePointer(e.clientX, e.clientY, true));
    addEventListener('mouseleave', () => { pointer.active = false; });
    addEventListener('touchstart', (e) => {
        const t = e.touches[0];
        updatePointer(t.clientX, t.clientY, true);
    }, { passive: true });
    addEventListener('touchmove', (e) => {
        const t = e.touches[0];
        updatePointer(t.clientX, t.clientY, true);
    }, { passive: true });
    addEventListener('touchend', () => { pointer.active = false; });

    addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    });

    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.033);
        const t = clock.elapsedTime;

        cakeGroup.rotation.y += 0.12 * dt;

        for (const p of particles) p.update(dt, pointer, t);

        for (const flame of flames) {
            const pulse = 1 + Math.sin(t * 8 + flame.seed) * 0.2;
            flame.light.intensity = 1.4 * pulse;
            flame.light.position.y = flame.center.y + Math.sin(t * 10 + flame.seed) * 0.08;
            for (const dot of flame.meshes) {
                dot.scale.setScalar(0.95 + Math.sin(t * 9 + dot.position.x * 3) * 0.08);
            }
        }

        renderer.render(scene, camera);
    }

    animate();
</script>
</body>
</html>
